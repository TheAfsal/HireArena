"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Interview_1 = require("../model/Interview");
const submitAptitudeTest_1 = __importDefault(require("../usecase/submitAptitudeTest"));
const gemini_helper_1 = __importDefault(require("../utils/gemini.helper"));
const grpcClient_1 = require("../config/grpcClient");
class AptitudeService {
    constructor(questionsRepo, interviewRepo, aptitudeResultRepo) {
        this.questionsRepo = questionsRepo;
        this.interviewRepo = interviewRepo;
        this.aptitudeResultRepo = aptitudeResultRepo;
    }
    async createAptitudeTest(jobId) {
        const questions = await gemini_helper_1.default.generateAptitudeQuestions();
        if (!questions || questions.length === 0) {
            throw new Error("No questions generated by AI.");
        }
        const formattedQuestions = questions.map((q) => ({
            q_id: q.id,
            question: q.question,
            options: q.options,
            correctAnswer: q.correctAnswer,
        }));
        console.log(formattedQuestions);
        return await this.questionsRepo.createAptitudeTest(jobId, formattedQuestions);
    }
    async fetchQuestions(jobId) {
        return await this.questionsRepo.getQuestions(jobId);
    }
    async scheduleAptitude(interviewId) {
        const now = new Date();
        const state = {
            roundType: Interview_1.RoundType["Aptitude Test"],
            status: Interview_1.RoundStatus.Failed,
            scheduledAt: now,
            createdAt: now,
            updatedAt: now,
        };
        await this.interviewRepo.updateAptitudeTestById(interviewId, state);
        return;
    }
    async submitTest(interviewId, data) {
        const application = await this.interviewRepo.findApplicationById(interviewId);
        if (!application) {
            throw new Error("False Submission");
        }
        const lastState = application.state[application.state.length - 1];
        console.log("@@lastState", lastState);
        const isAptitudeRound = lastState?.roundType === "Aptitude Test" &&
            lastState.status === Interview_1.RoundStatus.Failed;
        const scheduledAt = new Date(lastState.scheduledAt).getTime();
        const now = Date.now();
        const diffInMinutes = (now - scheduledAt) / (1000 * 60);
        const isWithinTimeLimit = diffInMinutes <= 31;
        console.log(isAptitudeRound, isWithinTimeLimit);
        if (isAptitudeRound && isWithinTimeLimit) {
            const submit = new submitAptitudeTest_1.default(this.questionsRepo, this.interviewRepo);
            let result = await submit.submitAptitudeTest(interviewId, application.jobId, data);
            console.log("@@ test result", result);
            const storedResult = await this.aptitudeResultRepo.saveResults(result);
            console.log("@@ storedResult", storedResult);
            if (storedResult.status === Interview_1.RoundStatus.Completed)
                await this.interviewRepo.addAptitudeTestId(interviewId, storedResult.id, true);
            else
                await this.interviewRepo.addAptitudeTestId(interviewId, storedResult.id);
            console.log("@@ application ", application);
            if (storedResult.status === Interview_1.RoundStatus.Completed) {
                const testOptions = [
                    "Machine Task",
                    "Technical Interview",
                    "Behavioral Interview",
                    "Coding Challenge",
                ];
                const jobDetails = await (0, grpcClient_1.IsJobExist)(application.jobId);
                const tests = JSON.parse(jobDetails.job.testOptions);
                if (!jobDetails)
                    throw new Error("Job not found");
                let nextTest = null;
                const now = new Date();
                for (let test of testOptions) {
                    if (tests[test] === true) {
                        nextTest = {
                            roundType: Interview_1.RoundType[test],
                            status: Interview_1.RoundStatus.Pending,
                            createdAt: now,
                            updatedAt: now,
                        };
                        break;
                    }
                }
                if (!nextTest) {
                    throw new Error("No pending test found to schedule next.");
                }
                await this.interviewRepo.addNextTest(interviewId, nextTest);
                return result;
            }
            return result;
        }
        else {
            throw new Error("Submission failed: Test window expired or invalid attempt.");
        }
    }
}
exports.default = AptitudeService;
