import * as grpc from "@grpc/grpc-js";
import * as protoLoader from "@grpc/proto-loader";
import { PrismaClient, RoundStatus, RoundType } from "@prisma/client";
import path from "path";
import dotenv from "dotenv";
import prisma from "./prismaClient";
import GeminiHelper from "../utils/gemini.helper";

dotenv.config();

const PROTO_PATH = path.resolve(__dirname, "../proto/interview.proto");
const packageDefinition = protoLoader.loadSync(PROTO_PATH);
const interviewProto = grpc.loadPackageDefinition(packageDefinition).interview;

const interviewService = {
  CreateInterview: async (call: any, callback: any) => {
    try {
      const { applicationId, jobId, jobSeekerId } = call.request;

      const interview = await prisma.interview.create({
        data: {
          applicationId,
          candidateId: jobSeekerId,
          jobId: jobId,
          status: "pending",
          scheduledAt: new Date(),
          InterviewRounds: {
            create: {
              roundType: RoundType.aptitude,
              status: RoundStatus.pending,
              scheduledAt: new Date(),
            },
          },
        },
      });

      callback(null, { interviewId: interview.id, status: interview.status });
    } catch (error) {
      console.error("Error creating interview:", error);
      callback({
        code: grpc.status.INTERNAL,
        message: "Failed to create interview",
      });
    }
  },

  CreateAptitudeTest: async (call: any, callback: any) => {
    try {
      const { jobId, companyId } = call.request;
      const result = await createAptitudeTest(jobId);
      callback(null, result);
    } catch (error) {
      callback(error, null);
    }
  },

  CreateMachineTask: async (call: any, callback: any) => {
    try {
      const { jobId, companyId } = call.request;
      const result = await createMachineTest(jobId,companyId);
      callback(null, result);
    } catch (error) {
      callback(error, null);
    }
  },

};

const server = new grpc.Server();

//@ts-ignore
server.addService(interviewProto.InterviewService.service, interviewService);

export default server;

async function createAptitudeTest(jobId: string) {
  try {
    console.log(`Generating aptitude test for job ${jobId}...`);

    const questions = await GeminiHelper.generateAptitudeQuestions();

    if (!questions || questions.length === 0) {
      throw new Error("No questions generated by AI.");
    }

    const aptitudeTestTemplate = await prisma.aptitudeTestTemplate.create({
      data: {
        jobId,
        name: `Aptitude Test for ${jobId}`,
      },
    });

    const formattedQuestions = questions.map((q: any) => ({
      templateId: aptitudeTestTemplate.id, 
      category: q.category,
      difficulty: q.difficulty,
      questionText: q.question,
      options: q.options,
      correctAnswer: q.correctAnswer,
    }));

    await prisma.aptitudeTestQuestion.createMany({
      data: formattedQuestions,
    });

    return { success: true, testId: aptitudeTestTemplate.id };
  } catch (error) {
    console.error("Error creating aptitude test:", error);
    throw error;
  }
}

async function createMachineTest(jobId: string, companyId:string) {
  try {
    console.log(`Generating machine task for job ${jobId}...`);
    
    const task = await GeminiHelper.generateMachineTask();
    
    const savedTask = await prisma.machineTask.create({
      data: {
        jobId,
        companyId,
        title: task.title,
        description: task.description,
        hoursToComplete: task.hoursToComplete,
        requirements: {
          create: task.requirements.map((requirement: string) => ({
            requirement,
          })),
        },
        evaluationCriteria: {
          create: task.evaluationCriteria.map((criteria: string) => ({
            criteria,
          })),
        },
      },
      include: {
        requirements: true,
        evaluationCriteria: true,
      },
    })    
    
    return savedTask;
  } catch (error) {
    console.error("Error saving machine task:", error);
    throw new Error("Failed to save machine task.");
  }
}

